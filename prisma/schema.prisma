generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["dataProxy"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String    @id @default(cuid()) // next-auth doesn't support UUIDs for its models.
  name             String    @default("")
  email            String    @unique
  emailVerified    DateTime? @map("email_verified")
  usedTechnologies String    @default("") @map("used_technologies")
  intendedUse      String    @default("") @map("intended_use")
  isAdmin          Boolean   @default(false) @map("is_admin")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  originUsers OriginUser[]

  @@map("users")
}

model OriginUser {
  id   String @id @default(uuid())
  role String @map("role")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  userId   String @map("user_id")
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  originId String @map("origin_id") @db.Uuid
  origin   Origin @relation(fields: [originId], references: [id], onDelete: Cascade)

  @@map("origin_users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  // Verification tokens are immutable so no need to store `updatedAt` info.
  createdAt DateTime @default(now()) @map("created_at")

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model WaitlistUser {
  id    String @id @default(uuid()) @db.Uuid
  email String @unique

  role             String
  useCases         String? @map("use_cases")
  howThisCouldHelp String? @map("how_this_could_help")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("waitlist_users")
}

model Origin {
  id     String @id @default(uuid()) @db.Uuid
  name   String @unique
  slug   String @unique
  apiKey String @unique @default(uuid()) @map("api_key") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  originUsers   OriginUser[]
  metrics       Metric[]
  dynamicRoutes DynamicRoute[]
  invites       OriginInvite[]

  @@map("origins")
}

model OriginInvite {
  id     String @id @default(uuid()) @db.Uuid
  email  String @unique
  origin Origin @relation(fields: [originId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  originId String @map("origin_id") @db.Uuid
  @@map("origin_invites")
}

model DynamicRoute {
  id      String @id @default(uuid()) @db.Uuid
  route   String
  pattern String

  originId String @map("origin_id") @db.Uuid
  origin   Origin @relation(fields: [originId], references: [id], onDelete: Cascade)

  @@unique([route, originId])
  @@unique([pattern, originId])
  @@map("dynamic_routes")
}

model Metric {
  id           String  @id @default(uuid()) @db.Uuid
  path         String
  queryParams  Json?   @map("query_params")
  method       String
  // Can't be nullable because we need to use `ARRAY_AGG` on this: https://github.com/prisma/prisma/issues/11339
  // Value 0 indicates that we didn't get a response status code from the middleware, can happen
  // e.g. when an inner request handler function that the middleware wraps throws an error.
  statusCode   Int     @default(0) @map("status_code")
  timeMillis   Int     @map("time_millis")
  requestSize  BigInt? @map("request_size")
  responseSize BigInt? @map("response_size")
  browser      String?
  os           String?
  device       String?
  cpuUsage     Float?  @map("cpu_usage")
  memoryUsage  BigInt? @map("memory_usage")
  memoryTotal  BigInt? @map("memory_total")

  apilyticsVersion String? @map("apilytics_version")

  // Metrics are immutable so no need to store `updatedAt` info.
  createdAt DateTime @default(now()) @map("created_at")

  originId String @map("origin_id") @db.Uuid
  origin   Origin @relation(fields: [originId], references: [id], onDelete: Cascade)

  @@map("metrics")
}

model EmailListEntry {
  email String @unique

  @@map("email_list_entries")
}
